/*
 * generated by Xtext 2.13.0
 */
package esir.compilation.generator

import esir.compilation.whdsl.Affect
import esir.compilation.whdsl.Call
import esir.compilation.whdsl.Command
import esir.compilation.whdsl.Cons
import esir.compilation.whdsl.EnclosedExpr
import esir.compilation.whdsl.Expr
import esir.compilation.whdsl.ExprAnd
import esir.compilation.whdsl.ExprEq
import esir.compilation.whdsl.ExprNot
import esir.compilation.whdsl.ExprOr
import esir.compilation.whdsl.Exprs
import esir.compilation.whdsl.For
import esir.compilation.whdsl.ForEach
import esir.compilation.whdsl.Function
import esir.compilation.whdsl.Hd
import esir.compilation.whdsl.If
import esir.compilation.whdsl.LExpr
import esir.compilation.whdsl.List
import esir.compilation.whdsl.Nill
import esir.compilation.whdsl.Nop
import esir.compilation.whdsl.Program
import esir.compilation.whdsl.Symbol
import esir.compilation.whdsl.Tl
import esir.compilation.whdsl.Variable
import esir.compilation.whdsl.Vars
import esir.compilation.whdsl.While
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class WhdslGenerator extends AbstractGenerator {
	
	
	String indent_value = '   ';
	String indent_if = '   ';
	String indent_for = '   ';
	String indent_while = '   ';
	String indent_foreach = '  ';

	
	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		for (e : resource.allContents.toIterable.filter(typeof(Program))){
			fsa.generateFile("sortie.whdsl", e.compile())
		}
	}
	
	def doGenerate (Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context, String sortie, String indent_value, String indent_if, String indent_for, 	String indent_foreach, String indent_while) {
		
		this.indent_value = indent_value;
		this.indent_if=indent_if;
		this.indent_for=indent_for;
		this.indent_foreach=indent_foreach;
		this.indent_while=indent_while;
		
		for (e : resource.allContents.toIterable.filter(typeof(Program))){
			fsa.generateFile(sortie, e.compile())
		}
	}
	
	def compile (Program p) {
		'''
		«FOR f : p.functions SEPARATOR '\n'»
			«f.compile(indent_value)»
		«ENDFOR»
		'''
	}
	
	def compile (Function f, String indent) {
		'''
		function «f.name»:
		read «f.definition.input.vars.compile()»
		%
		«FOR cmd: f.definition.commands.list SEPARATOR ';'»
			«indent»«cmd.compile(indent)»
		«ENDFOR»
		%
		write «f.definition.output.vars.compile()»
		'''
	}
	
	
	def compile (Command c, String indent){
		if(c.cmd instanceof Nop){
			(c.cmd as Nop).compile();
		}
		else if(c.cmd instanceof Affect){
			(c.cmd as Affect).compile();
		}
		else if(c.cmd instanceof If){
			(c.cmd as If).compile(indent);	
		}
		else if(c.cmd instanceof For){
			(c.cmd as For).compile(indent);
		}
		else if(c.cmd instanceof ForEach){
			(c.cmd as ForEach).compile(indent);
		}
		else if(c.cmd instanceof While){
			(c.cmd as While).compile(indent);
		}
		
	}
	
	def compile(Nop n) {
		'''nop'''
	}
	
	def compile(Vars vars) {
		'''«vars.list.join(', ')»'''
	}
	
	def compile(Exprs exprs) {
		'''«FOR exp: exprs.list SEPARATOR ','»«exp.compile()»«ENDFOR»'''
	}
	
	def compile(LExpr lexprs) {
		'''«FOR exp: lexprs.list SEPARATOR ' '»«exp.compile()»«ENDFOR»'''
	}
	
	def compile(Expr e){
		e.compileExpr()
	}

	def dispatch compileExpr(Variable v) {
		'''«v.value»'''
	}
	
	def dispatch compileExpr(Symbol s) {
		'''«s.value»'''
	}
	
	def dispatch compileExpr(Nill n) {
		'''nil'''
	}
	
	def dispatch compileExpr(ExprAnd e) {
		'''«e.left.compile()» and «e.right.compile()»'''
	}
	
	def dispatch compileExpr(ExprOr e) {
		'''«e.left.compile()» or «e.right.compile()»'''
	}
	
	def dispatch compileExpr(ExprEq e) {
		'''«e.left.compile()» =? «e.right.compile()»'''
	}
	
	def dispatch compileExpr(ExprNot e) {
		'''not «e.expr.compile()»'''
	}
	
	def dispatch compileExpr(Cons c) {
		'''(cons «c.exprs.compile()»)'''
	}
	
	def dispatch compileExpr(List l) {
		'''(list «l.exprs.compile()»)'''
	}
	
	def dispatch compileExpr(Hd hd) {
		'''(hd «hd.expr.compile()»)'''
	}
	
	def dispatch compileExpr(Tl tl) {
		'''(tl «tl.expr.compile()»)'''
	}
	
	def dispatch compileExpr(Call c) {
		'''(«c.name» «c.params.compile()»)'''
	}
	
	def dispatch compileExpr(EnclosedExpr ie) {
		'''(«ie.expr.compile()»)'''
	}
	
	def compile(Affect a) {
		'''«a.vars.compile()» := «a.exprs.compile()»'''
	}
	
	def compile(If i, String indent) {
		'''
		if «i.condition.compile()» then
		«FOR cmd: i.thenCommands.list SEPARATOR ';'»
			«indent+indent_if»«cmd.compile(indent+indent_if)»
		«ENDFOR»
		«indent»else
		«FOR cmd: i.elseCommands.list SEPARATOR ';'»
			«indent+indent_if»«cmd.compile(indent+indent_if)»
		«ENDFOR»
		«indent»fi
		'''
	}
	
	def compile(For f, String indent) {
		'''
		for «f.condition.compile()» do
		«FOR cmd: f.commands.list SEPARATOR ';'»
			«indent+indent_for»«cmd.compile(indent+indent_for)»
		«ENDFOR»
		«indent»od
		'''
	}
	
	def compile(ForEach f, String indent) {
		'''
		foreach «f.elem.compile()» in «f.ensemb.compile()» do
		«FOR cmd: f.commands.list SEPARATOR ';'»
			«indent+indent_foreach»«cmd.compile(indent+indent_foreach)»
		«ENDFOR»
		«indent»od
		'''
	}
	
	def compile(While w, String indent) {
		'''
		while «w.condition.compile()» do
		«FOR cmd: w.commands.list SEPARATOR ';'»
			«indent+indent_while»«cmd.compile(indent+indent_while)»
		«ENDFOR»
		«indent»od
		'''
	}

}