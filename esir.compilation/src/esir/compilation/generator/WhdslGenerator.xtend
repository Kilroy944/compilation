
/*
 * generated by Xtext 2.13.0
 */
package esir.compilation.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import esir.compilation.whdsl.Function
import esir.compilation.whdsl.Program
import esir.compilation.whdsl.Commands
import esir.compilation.whdsl.impl.CommandsImpl
import esir.compilation.whdsl.Exprs
import esir.compilation.whdsl.Command
import esir.compilation.whdsl.Vars
import esir.compilation.whdsl.impl.CommandImpl
import esir.compilation.whdsl.Nop
import esir.compilation.whdsl.Affect
import esir.compilation.whdsl.While
import esir.compilation.whdsl.For
import esir.compilation.whdsl.If

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class WhdslGenerator extends AbstractGenerator {

	
	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		for (e : resource.allContents.toIterable.filter(typeof(Program))){
			fsa.generateFile("sortie.whdsl", e.compile())
		}
	}
	
	def doGenerate (Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context, String sortie) {
		for (e : resource.allContents.toIterable.filter(typeof(Program))){
			fsa.generateFile(sortie, e.compile())
		}
	}
	
	def compile (Program p){'''
		«FOR f : p.function»
		«f.compile()»
		«ENDFOR»
		'''
	}
	
	def compile (Function f){
		'''
		function «f.name»:
		read «FOR param: f.definition.input.variables SEPARATOR ', '»«param»«ENDFOR»
		%
		«f.definition.commands.command.compile()»«FOR param: f.definition.commands.commands»;
		«param.compile()»
		«ENDFOR»
		%
		write «FOR param: f.definition.output.variables SEPARATOR ', '»«param»«ENDFOR»'''
	}
	
	
	def compile (Command c){
		if(c.cmd instanceof Nop){
			(c.cmd as Nop).compile();
		}
		else if(c.cmd instanceof Affect){
			(c.cmd as Affect).compile();
		}
		else if(c.cmd instanceof If){
			(c.cmd as If).compile();	
		}
		else if(c.cmd instanceof For){
			(c.cmd as For).compile();
		}
		else if(c.cmd instanceof While){
			(c.cmd as While).compile();
		}
		
	}
	
	def compile(Nop n){
		'''nop'''
	}
	
	def compile(Affect a){
		'''«a.vars.compile()»:=«a.exprs.compile()»'''	
	}
	def compile(If i){
		'''if «i.exprs.compile()» then 
«i.cmds1.command.compile()»«FOR param: i.cmds1.commands»;
«param.compile()»«ENDFOR»
else
«i.cmds2.command.compile()»«FOR param: i.cmds2.commands»;
«param.compile()»«ENDFOR»
fi'''			
	}
	
	def compile(For f){
		'''for «f.exprs.compile()» do
«f.cmds.command.compile()»«FOR param: f.cmds.commands»;
«param.compile()»
		«ENDFOR»
od'''		
	}
	
	def compile(While w){
		'''while «w.exprs.compile()» do
«w.cmds.command.compile()»«FOR param: w.cmds.commands»;
«param.compile()»
		«ENDFOR»
od'''	
	}

	def compile(Vars v){
		'''«v.^var»«FOR param: v.vars »,«param»«ENDFOR»'''
	}

	

	def compile(Exprs e){
		'''«e.expr»«FOR param: e.exprs»,«param»«ENDFOR»'''
	}
	
	
	
}